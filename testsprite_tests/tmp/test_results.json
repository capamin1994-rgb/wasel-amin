[
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "3cc577dd-cfc2-4da3-ba2f-9f23b27fa3d3",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC001-User Registration with Valid Data",
    "description": "Verify that a user can successfully register with valid and complete registration data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Correct the URL or find a valid link to the registration page.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'إنشاء حساب' (Create Account) link to go to the registration page.\n        frame = context.pages[-1]\n        # Click on the 'إنشاء حساب' (Create Account) link to navigate to the registration page.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid user details into the registration form fields: full name, WhatsApp number, check WhatsApp checkbox, email, and password.\n        frame = context.pages[-1]\n        # Input full name\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input WhatsApp number\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the WhatsApp checkbox\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input email\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Submit the registration form\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=مرحباً، Test User').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that a user can successfully register with valid and complete registration data. However, the last action performed was an attempt to navigate to the registration page at 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, possibly due to the server being down, the URL being incorrect, or network issues. \n\nTo resolve this, you should check the following:\n1. **URL Validity**: Ensure that 'http://localhost:3001/' is the correct URL for the registration page. If the server is not running or the URL is incorrect, the page will not load.\n2. **Server Status**: Verify that the server hosting the application is up and running. If the server is down, you will need to start it.\n3. **Network Issues**: Check for any network connectivity issues that might prevent access to the local server.\n\nOnce these issues are addressed, you can retry the action to see if the registration page loads successfully.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459370354875//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.264Z",
    "modified": "2026-01-15T06:42:51.157Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "8ed05194-87cb-467e-80ea-8f77d1145c1b",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC002-User Registration with Missing Required Fields",
    "description": "Ensure the system handles missing required registration fields correctly by showing appropriate validation errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to find a correct link or button on the current page or navigate properly to the registration page.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'إنشاء حساب' link to go to the registration page.\n        frame = context.pages[-1]\n        # Click on 'إنشاء حساب' link to navigate to the registration page\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Submit the registration form with all required fields left empty to check validation errors.\n        frame = context.pages[-1]\n        # Click the submit button 'تسجيل وبدء الباقة' with empty required fields to trigger validation errors\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test validation for other required fields by attempting to submit the form leaving each required field empty one by one and checking for validation errors.\n        frame = context.pages[-1]\n        # Clear the Full Name field to test validation on it again\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click submit button to trigger validation error for Full Name field\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Fill Full Name field to move to next field validation\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Clear WhatsApp Number field to test validation on it\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click submit button to trigger validation error for WhatsApp Number field\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test validation for the remaining required fields: Email and Password by submitting the form with each left empty and checking for validation errors.\n        frame = context.pages[-1]\n        # Fill WhatsApp Number field to move to next field validation\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0123456789')\n        \n\n        frame = context.pages[-1]\n        # Clear Email field to test validation on it\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click submit button to trigger validation error for Email field\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test validation for the last required field: Password by submitting the form with it left empty and checking for validation error.\n        frame = context.pages[-1]\n        # Fill Email field to move to next field validation\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('example@mail.com')\n        \n\n        frame = context.pages[-1]\n        # Clear Password field to test validation on it\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click submit button to trigger validation error for Password field\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=الاسم الكامل').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=رقم الواتساب').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=البريد الإلكتروني').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=كلمة المرور').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=تسجيل وبدء الباقة').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that the system correctly handles missing required registration fields by displaying appropriate validation errors. However, the last action performed was an attempt to navigate to the registration page at 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, preventing any further actions or validations from being executed. \n\nThe error occurred because the system could not reach the specified URL, possibly due to the server being down, the URL being incorrect, or network issues. As a result, the validation checks for missing registration fields could not be performed, and the test did not pass. To resolve this, ensure that the server is running, the URL is correct, and that there are no network issues before attempting to navigate to the page again.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459370495358//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.271Z",
    "modified": "2026-01-15T06:42:50.631Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "db96dbb6-74c9-4741-a379-cb419f8428c2",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC003-User Login with Correct Credentials",
    "description": "Verify that a user can successfully log in with valid credentials and that JWT and cookies are correctly set.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Correct the URL and navigate to the proper login page.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the login link to navigate to the login page.\n        frame = context.pages[-1]\n        # Click on the 'دخول' (Login) link to go to the login page\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid username/email and password into the respective fields.\n        frame = context.pages[-1]\n        # Input valid username/email\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validpassword123')\n        \n\n        # -> Click the login button to submit the login form and proceed to verify login success and token/cookie setup.\n        frame = context.pages[-1]\n        # Click the 'دخول' (Login) button to submit the login form\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid username/email and password again with correct credentials and retry login.\n        frame = context.pages[-1]\n        # Input valid username/email with correct credentials\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('correctuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password with correct credentials\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('correctpassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the 'دخول' (Login) button to submit the form with correct credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome user')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: User login was not successful, or JWT token and session cookies were not properly set as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify a successful login with valid credentials, ensuring that JWT and cookies are set correctly. However, the last action of navigating to the login page at 'http://localhost:3001/' failed due to a timeout error. This indicates that the page did not load within the specified 10 seconds, which could be due to several reasons such as the server being down, the URL being incorrect, or network issues. As a result, the login process could not be initiated, preventing any further verification of JWT and cookies. To resolve this, check the server status, confirm the URL is correct, and ensure there are no network connectivity issues.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459368284573//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.279Z",
    "modified": "2026-01-15T06:42:48.403Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "a6ee5ccb-9cea-4cfd-a790-b14e50035bc3",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC004-User Login with Invalid Credentials",
    "description": "Check that login fails when the user enters incorrect username or password and proper error messages are displayed.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Correct the URL or find a valid link to the login page to proceed.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the login link to navigate to the login page.\n        frame = context.pages[-1]\n        # Click on the 'دخول' (Login) link to go to the login page.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input incorrect username/email and password into the respective fields.\n        frame = context.pages[-1]\n        # Input incorrect username/email\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wronguser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input incorrect password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wrongpassword')\n        \n\n        # -> Click the login button to attempt login with incorrect credentials and verify the error message.\n        frame = context.pages[-1]\n        # Click the 'دخول' (Login) button to submit the incorrect credentials.\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=بيانات الدخول غير صحيحة').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that a login attempt with incorrect credentials results in a failure and displays the appropriate error messages. However, the last action performed was an attempt to navigate to the login page at 'http://localhost:3001/', which failed due to a timeout error. This indicates that the page did not load within the expected time frame of 10 seconds, likely because the URL is incorrect, the server is down, or there is a network issue. As a result, the test could not proceed to check the login functionality, leading to a failure in meeting the task goal. To resolve this, please verify the URL and ensure that the server is running and accessible.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369234802//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.286Z",
    "modified": "2026-01-15T06:42:49.856Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "f3a41756-e723-443a-bf4f-579d891bad16",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC005-Add WhatsApp Session via QR Code",
    "description": "Ensure that a user can add a WhatsApp session by scanning the QR code and that the system establishes the session correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find a correct way to navigate to the WhatsApp session management page or reload the base page to find navigation options.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the link or button that leads to WhatsApp session management.\n        frame = context.pages[-1]\n        # Click on the 'واتساب بوت بيتا' link to navigate to WhatsApp session management or related page.\n        elem = frame.locator('xpath=html/body/header/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=WhatsApp session established successfully').first).to_be_visible(timeout=10000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The WhatsApp session was not established successfully as required by the test plan. The session QR code might not have been scanned or linked correctly to the user account.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that a user can successfully add a WhatsApp session by scanning a QR code, which requires navigating to the appropriate session management page. However, the last action performed was a navigation attempt to 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected timeframe, possibly due to the server being down, the URL being incorrect, or network issues. As a result, the system could not establish the session as intended, leading to the failure of the task. To resolve this, check the server status, verify the URL, and ensure that the network connection is stable.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459370058238//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.293Z",
    "modified": "2026-01-15T06:42:50.627Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "6e3d3854-e8d9-4689-b61f-90a26b9dfcbf",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC006-Fail to Establish WhatsApp Session on Invalid QR Code",
    "description": "Validate that the system correctly handles the case when an invalid QR code is scanned and session establishment fails.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n \n        # -> Navigate to the correct URL or find a clickable element to open the WhatsApp session connection page.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the link or button that leads to WhatsApp session connection or login to start the QR code scanning process.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input test credentials and submit the login form to try to reach the WhatsApp session connection or QR code scanning interface.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidpassword')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Session connected successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: The session connection did not fail as expected when an invalid QR code was scanned. No error notification was shown indicating session establishment failure.')\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to validate the system's handling of an invalid QR code scan, specifically ensuring that session establishment fails as expected. However, the last action attempted to navigate to the URL 'http://localhost:3001/' but encountered a timeout error after 10 seconds, indicating that the page did not load within the expected timeframe. This suggests that either the server at that address is not running, the URL is incorrect, or there is a network issue preventing access to the page. As a result, the test could not proceed to validate the QR code handling, leading to a failure in the test case.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459367859274//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.301Z",
    "modified": "2026-01-15T06:42:48.589Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "6b0d58a2-e42d-42f3-bbaa-0463d4009d98",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC007-Set User Location Manually",
    "description": "Verify the user can manually select their country and location is saved and reflected correctly in user settings.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the main page or dashboard where user settings can be accessed.\n        await page.goto('http://localhost:3001', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'دخول' (Login) link to proceed to the login page.\n        frame = context.pages[-1]\n        # Click on the 'دخول' (Login) link to navigate to the login page.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid credentials and click the login button to proceed.\n        frame = context.pages[-1]\n        # Input the phone or email for login.\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input the password for login.\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials.\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and click the user settings link or menu to access location settings.\n        frame = context.pages[-1]\n        # Click on 'تسجيل خروج' (Logout) to check if user settings are accessible from the dashboard or to find user settings link.\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Location Saved Successfully').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The user was unable to manually select their country and have the location saved and reflected correctly in user settings as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that a user can manually select their country and that this selection is saved and reflected correctly in the user settings. However, the last action performed was to navigate to the main page or dashboard at 'http://localhost:3001', which failed due to a timeout error. The error message indicates that the page did not load within the specified 10 seconds, causing the action to fail. \n\nThis timeout could occur for several reasons: the server at 'http://localhost:3001' may not be running, there could be network issues, or the page may be taking too long to respond. As a result, since the navigation to the page was unsuccessful, you were unable to proceed with verifying the country selection functionality. To resolve this, ensure that the server is running and accessible, and consider checking for any network issues that might be affecting the connection.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/17684593697572//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.309Z",
    "modified": "2026-01-15T06:42:49.879Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "45b918de-bb40-4dde-9b5d-794ead3fe5e2",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC008-Set User Location Automatically",
    "description": "Confirm that the system can automatically set user location using available data and update settings accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Resolve the URL issue or find a correct navigation path to access user settings.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to user settings by finding and clicking the appropriate link or button.\n        frame = context.pages[-1]\n        # Click on 'دخول' (Login) to access user account options and settings.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input user credentials and submit login form to access user settings.\n        frame = context.pages[-1]\n        # Input user email or phone in login field\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input user password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Request valid user credentials or explore alternative ways to access user settings to enable automatic location detection.\n        frame = context.pages[-1]\n        # Click on 'إنشاء حساب جديد' (Create new account) to explore if account creation or alternative access is possible.\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form with valid data and submit to create a new account.\n        frame = context.pages[-1]\n        # Input full name in registration form\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input WhatsApp number in registration form\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the WhatsApp number confirmation checkbox\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input email in registration form\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password in registration form\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the submit button to register and start the package\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to login page to attempt login with existing credentials and proceed to user settings.\n        frame = context.pages[-1]\n        # Click on 'تسجيل الدخول' (Login) link to go back to the login page\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid user credentials and submit login form to access user settings.\n        frame = context.pages[-1]\n        # Input user email or phone in login field\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input user password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and click on the user settings or profile menu to access settings for enabling automatic location detection.\n        frame = context.pages[-1]\n        # Click on the user greeting or profile menu 'مرحباً، Test User' to find user settings options\n        elem = frame.locator('xpath=html/body/div[2]/aside/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Automatic Location Detection Enabled').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The system did not automatically detect and save the user location in settings as expected according to the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to confirm that the system can automatically set the user location and update settings accordingly. However, the last action performed was a navigation attempt to 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, preventing the test from proceeding. \n\nThe error occurred because the URL may be incorrect, the server might not be running, or there could be network issues preventing access to the page. To resolve this, check if the server at 'http://localhost:3001/' is up and running, verify the URL for accuracy, and ensure there are no network connectivity problems. Once the navigation issue is resolved, you can reattempt the action to confirm the system's functionality.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459368508406//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.317Z",
    "modified": "2026-01-15T06:42:49.740Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "7649135f-4c5d-47de-9dc1-a66a0c95b4af",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC009-Configure Morning and Evening Adhkar Reminders",
    "description": "Verify user can enable and configure morning and evening Adhkar reminders with preferred timings.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check and correct the URL or find a valid entry point to the reminder configuration page.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to reminder configuration page by clicking the appropriate link or button.\n        frame = context.pages[-1]\n        # Click on 'ابدأ التجربة المجانية' (Start free trial) to proceed to the reminder configuration or account creation.\n        elem = frame.locator('xpath=html/body/main/section/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form with valid user details and submit to create an account.\n        frame = context.pages[-1]\n        # Input full name in registration form\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input WhatsApp number\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the WhatsApp confirmation checkbox\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click on register and start package button to submit the form\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the login link to navigate to the login page and proceed with login.\n        frame = context.pages[-1]\n        # Click on 'تسجيل الدخول' link to go to the login page for existing users\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid phone/email and password, then click the login button to log in.\n        frame = context.pages[-1]\n        # Input phone number or email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'التذكيرات الإسلامية' link to navigate to the Islamic reminders configuration page.\n        frame = context.pages[-1]\n        # Click on 'التذكيرات الإسلامية' link to go to the reminder configuration page\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Enable morning Adhkar reminder and set the preferred time.\n        frame = context.pages[-1]\n        # Click on 'إعدادات الأذكار' button under the morning prayer section to configure morning Adhkar reminders\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div/div[2]/div[4]/div/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Change the time delay for morning Adhkar reminder to 10 minutes and save the settings.\n        frame = context.pages[-1]\n        # Change the time delay for morning Adhkar reminder to 10 minutes\n        elem = frame.locator('xpath=html/body/div[7]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('10')\n        \n\n        frame = context.pages[-1]\n        # Click on save changes button to save morning Adhkar reminder settings\n        elem = frame.locator('xpath=html/body/div[7]/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the morning Adhkar settings modal if needed, then open the evening Adhkar reminder settings modal to enable and set the preferred time.\n        frame = context.pages[-1]\n        # Click save button again to confirm and close modal if needed\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div/div[2]/div[4]/div/div[2]/div[2]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Open the evening Adhkar reminder settings modal to enable and set the preferred time.\n        frame = context.pages[-1]\n        # Click on 'إعدادات' button for evening Adhkar reminder to open its settings modal\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div/div[2]/div[4]/div[4]/div[3]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Change the time delay for evening Adhkar reminder to 15 minutes and save the settings.\n        frame = context.pages[-1]\n        # Change the time delay for evening Adhkar reminder to 15 minutes\n        elem = frame.locator('xpath=html/body/div[7]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('15')\n        \n\n        frame = context.pages[-1]\n        # Click on save changes button to save evening Adhkar reminder settings\n        elem = frame.locator('xpath=html/body/div[7]/div/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify the reminders are scheduled and functional by clicking the 'اختبار الأذكار' (Test Adhkar) buttons for morning and evening reminders.\n        frame = context.pages[-1]\n        # Click on 'اختبار الأذكار' button for morning Adhkar reminder to test the reminder functionality\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div/div[2]/div[4]/div/div[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the test modal and proceed to test the evening Adhkar reminder.\n        frame = context.pages[-1]\n        # Click on 'إلغاء' button to close the morning Adhkar test reminder modal\n        elem = frame.locator('xpath=html/body/div[5]/div/div[6]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=اختبار الأذكار').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=حفظ إعدادات الصلاة').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10 دقيقة').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=15 دقيقة').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that the user can enable and configure morning and evening Adhkar reminders with preferred timings. However, the last action performed was a navigation attempt to the URL 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, likely due to one of the following reasons:\n\n1. **Server Not Running**: The server hosting the application may not be running, preventing the page from loading.\n2. **Incorrect URL**: The URL may be incorrect or the application may not be deployed at that address.\n3. **Network Issues**: There could be network connectivity issues affecting access to the server.\n\nTo resolve this, please check if the server is running and accessible at the specified URL. If the server is running, verify that the URL is correct and that there are no network issues preventing access.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369922077//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.328Z",
    "modified": "2026-01-15T06:42:50.705Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "be9b1117-342f-402e-9571-10adf57f9eb0",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC010-Add Custom Islamic Reminder with Invalid Time",
    "description": "Validate that the system rejects custom reminder creation when invalid time formats are provided.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to find a valid navigation element or correct URL to access the reminder creation page.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the element that leads to custom reminder creation or start free trial to access reminder creation.\n        frame = context.pages[-1]\n        # Click on 'ابدأ التجربة المجانية' (Start free trial) to access reminder creation.\n        elem = frame.locator('xpath=html/body/main/section/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the registration form with valid data and submit to create an account.\n        frame = context.pages[-1]\n        # Enter full name in registration form\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Enter WhatsApp phone number\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Enter email address\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Enter password\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click on 'تسجيل وبدء الباقة' to submit registration form\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'تسجيل الدخول' link to go to the login page.\n        frame = context.pages[-1]\n        # Click on 'تسجيل الدخول' link to navigate to login page\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input existing user credentials and click login to proceed.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'التذكيرات الإسلامية' link to navigate to Islamic reminders page where custom reminders can be created.\n        frame = context.pages[-1]\n        # Click on 'التذكيرات الإسلامية' link to go to reminders page\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and click the button or link to create a new custom reminder.\n        frame = context.pages[-1]\n        # Click on 'المستلمين والإتصال' tab to access recipients and reminder settings\n        elem = frame.locator('xpath=html/body/div[2]/main/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'إضافة' (Add) button to explore if it opens a form or options for creating a custom reminder.\n        frame = context.pages[-1]\n        # Click on 'إضافة' (Add) button in recipients tab\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div[4]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close this form and try to locate the custom reminder creation form elsewhere, as this form is for adding recipients, not reminders.\n        frame = context.pages[-1]\n        # Click 'إلغاء' (Cancel) button to close the add new recipient form\n        elem = frame.locator('xpath=html/body/div[3]/div/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'الأذكار والمحتوى' tab to explore if it contains the custom reminder creation form.\n        frame = context.pages[-1]\n        # Click on 'الأذكار والمحتوى' tab\n        elem = frame.locator('xpath=html/body/div[2]/main/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'جدولة خاصة' (Special Schedule) button to try to access custom reminder creation or time setting form.\n        frame = context.pages[-1]\n        # Click on 'جدولة خاصة' (Special Schedule) button to access custom reminder creation or time setting form\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div[2]/div[3]/div/div/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to test invalid time format rejection by entering invalid values in other related fields or by submitting the form with missing or invalid time data, or report that invalid time format input cannot be tested due to input type restrictions.\n        frame = context.pages[-1]\n        # Input title for the schedule\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div[2]/div[3]/div/div[2]/div[10]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Invalid Time Test')\n        \n\n        frame = context.pages[-1]\n        # Input message content\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div[2]/div[3]/div/div[2]/div[10]/div[2]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('This is a test message with invalid time format.')\n        \n\n        frame = context.pages[-1]\n        # Click save schedule button to attempt saving with invalid or missing time input\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div[2]/div[3]/div/div[2]/div[10]/div[2]/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=اختر وقت').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to validate that the system rejects custom reminder creation when invalid time formats are provided. However, the last action performed was an attempt to navigate to the URL 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load successfully within the expected time frame, preventing any further actions from being executed, including the validation of the reminder creation functionality.\n\nThe error occurred because the system could not reach the specified URL, which could be due to several reasons such as the server not running, the URL being incorrect, or network issues. As a result, the test could not proceed to check if the system correctly handles invalid time formats for reminders. To resolve this, ensure that the server is running and accessible at the specified URL, and verify that the URL is correct.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459368590411//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.336Z",
    "modified": "2026-01-15T06:42:49.409Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "640ffeb7-6e32-4dae-a2c7-b96613a262e6",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC011-Send Islamic Reminder via WhatsApp",
    "description": "Verify that scheduled Islamic reminders (Adhkar, fasting) are sent correctly via WhatsApp at configured times.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n\n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n\n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n\n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n\n        # Open a new page in the browser context\n        page = await context.new_page()\n\n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n\n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n\n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n\n        # Interact with the page elements to simulate user flow\n \n        # -> Check if there is a correct URL or alternative way to access the application or interface to start the test.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the login link to ensure WhatsApp session is active.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input phone/email and password, then click login button to activate WhatsApp session.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'إضافة جلسة جديدة' (Add New Session) button to start adding a WhatsApp session.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the session name, select linking method as 'رقم الهاتف' (phone number), confirm country as مصر (Egypt), input a valid phone number, then click 'توليد كود الربط' (Generate linking code) to proceed.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Session')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[2]/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[3]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'توليد كود الربط' (Generate linking code) button to generate the WhatsApp linking code and proceed to scan QR or confirm linking.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[3]/div/div/div[2]/div[24]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'توليد كود الربط' button to generate the WhatsApp linking code and proceed with session activation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Change the country selection to Egypt (+20) to match the phone number prefix, then click 'توليد كود الربط' (Generate linking code) button to generate the WhatsApp linking code.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[3]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'مصر' (Egypt) from the country list to set the correct country code +20, then input the phone number without country code and click 'توليد كود الربط' (Generate linking code).\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[3]/div/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'توليد كود الربط' (Generate linking code) button to generate the WhatsApp linking code and proceed with session activation.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear the phone number field and input a valid Egyptian phone number without the country code, then click 'توليد كود الربط' (Generate linking code) again to generate the WhatsApp linking code.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[3]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1012345678')\n        \n\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[3]/div/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Close the linking modal and navigate to the 'التذكيرات الإسلامية' (Islamic Reminders) tab to configure a reminder schedule for a near future time.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[5]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'إعادة الاتصال بالكل' (Reconnect All) button to attempt reconnecting the WhatsApp session and activate it.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/main/div[2]/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'التذكيرات الإسلامية' (Islamic Reminders) tab to configure a reminder schedule for a near future time.\n        frame = context.pages[-1]\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Reminder Delivered Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Scheduled Islamic reminders (Adhkar, fasting) were not delivered via WhatsApp at the configured times as expected.\")\n        await asyncio.sleep(5)\n\n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n\nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that scheduled Islamic reminders are sent correctly via WhatsApp at configured times. However, the last action performed was a navigation attempt to the URL 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, possibly due to the server not running, incorrect URL, or network issues. As a result, the test could not proceed, and the verification of the reminders could not be completed. To resolve this, ensure that the server hosting the application is running and accessible, and verify that the URL is correct.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369996188//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.344Z",
    "modified": "2026-01-15T06:42:50.116Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "70986e9d-beda-4a14-9817-8c20768d2c4f",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC012-Handle Reminder Sending Failure due to WhatsApp Session Lost",
    "description": "Ensure the system correctly logs and handles errors occurring when reminders fail to send due to WhatsApp session disconnection.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to a valid starting page or correct the URL to access the application interface.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Invalidate the WhatsApp session to simulate disconnection.\n        frame = context.pages[-1]\n        # Click on 'دخول' (Login) to access the user account area where session management might be available.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid credentials and submit login form to access user account area.\n        frame = context.pages[-1]\n        # Input the phone number or email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('password123')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Explore alternative ways to invalidate the WhatsApp session or find a way to reset session without login.\n        frame = context.pages[-1]\n        # Click 'عودة للرئيسية' to return to the main page and check for other navigation options or session management features.\n        elem = frame.locator('xpath=html/body/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try alternative navigation or actions to invalidate WhatsApp session or trigger reminder sending without login.\n        frame = context.pages[-1]\n        # Click on 'واصل' button to see if it leads to a page or area where session can be invalidated or reminders triggered.\n        elem = frame.locator('xpath=html/body/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'إنشاء حساب' (Create Account) to check if account creation or session management options are available that might help invalidate the WhatsApp session.\n        frame = context.pages[-1]\n        # Click on 'إنشاء حساب' (Create Account) to explore account creation or session management options.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form with valid data to create a new account, which might help in session management or testing reminder sending.\n        frame = context.pages[-1]\n        # Input full name in the registration form\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input WhatsApp number in the registration form\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the box indicating the number has WhatsApp\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input email address in the registration form\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password in the registration form\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Click the register and start package button to submit the registration form\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to navigate to the login page to attempt login with possibly different credentials or to find a way to invalidate the WhatsApp session.\n        frame = context.pages[-1]\n        # Click on 'تسجيل الدخول' (Login) link to navigate to the login page.\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input credentials to login and access user account area for session invalidation.\n        frame = context.pages[-1]\n        # Input the phone number or email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input the password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Password123!')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to invalidate the WhatsApp session by other means or trigger the sending of a scheduled reminder to test error handling when session is disconnected.\n        frame = context.pages[-1]\n        # Click on 'عودة للرئيسية' to return to the main page and explore other options for session invalidation or reminder sending.\n        elem = frame.locator('xpath=html/body/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try alternative navigation or actions to invalidate WhatsApp session or trigger reminder sending without relying on 'عودة للرئيسية' link.\n        frame = context.pages[-1]\n        # Click on 'واصل' button to explore if it leads to a page or area where session can be invalidated or reminders triggered.\n        elem = frame.locator('xpath=html/body/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=خدمة التذكير الإسلامي عبر واتساب').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=نعم، نقدم باقة تجريبية مجانية لتجربة كافة المميزات.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=© 2024 جميع الحقوق محفوظة لمنصة واتساب بوت.').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that the system correctly logs and handles errors when reminders fail to send due to a WhatsApp session disconnection. However, the last action performed was a navigation attempt to the URL 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, possibly due to the server being down, the URL being incorrect, or network issues. \n\nThe error message specifically states that the navigation to the page timed out while waiting for the page to load. This means that the application interface could not be accessed, preventing any further actions or error handling related to the reminder sending process. To resolve this, you should check if the server at 'http://localhost:3001/' is running, verify the URL for correctness, and ensure there are no network issues preventing access.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369427992//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.351Z",
    "modified": "2026-01-15T06:42:50.090Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "1fbbdce4-2409-44a5-b4d8-b183c85ec674",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC013-Admin Dashboard User Listing and Search",
    "description": "Check that admin can view, search, and paginate through the list of users in the admin dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the correct admin dashboard login page or home page to start login as admin.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'دخول' (Login) link to start admin login.\n        frame = context.pages[-1]\n        # Click on the 'دخول' (Login) link to go to the login page.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input admin phone/email and password, then click login button.\n        frame = context.pages[-1]\n        # Input admin phone/email\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('adminpassword')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit admin credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input correct admin credentials and click login button to access admin dashboard.\n        frame = context.pages[-1]\n        # Input correct admin email for admin login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@admin.com')\n        \n\n        frame = context.pages[-1]\n        # Input correct admin password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('correctpassword')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit correct admin credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User list updated successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution failed because the admin was unable to view, search, or paginate through the list of users in the admin dashboard as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that the admin can view, search, and paginate through the list of users in the admin dashboard. However, the last action performed was to navigate to the admin dashboard at 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, preventing the admin from accessing the dashboard. \n\nThe error occurred because the page either took too long to respond, the server might be down, or the URL could be incorrect. To resolve this, check if the server is running and accessible at the specified URL, and ensure that there are no network issues. Once the page loads successfully, you can proceed with verifying the admin functionalities.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459368888741//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.363Z",
    "modified": "2026-01-15T06:42:49.012Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "663796f5-74f6-47b8-b92c-e52ba7c27f08",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC014-Admin Modify User Subscription Plan",
    "description": "Ensure admin can update a user's subscription plan and the change is reflected immediately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the correct admin dashboard URL to access the user profile.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the login link to access admin features and navigate to a user's profile.\n        frame = context.pages[-1]\n        # Click on the 'دخول' (Login) link to access admin login.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input admin phone/email and password, then click login button.\n        frame = context.pages[-1]\n        # Input admin phone/email\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('adminpassword')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Subscription Plan Updated Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The subscription plan update was not reflected immediately as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that an admin can update a user's subscription plan and that the change is reflected immediately. However, the last action performed was to navigate to the admin dashboard URL (http://localhost:3001/), which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected timeframe, preventing the admin from accessing the user profile to make the necessary updates. \n\nThe error occurred because the page either took too long to respond, possibly due to server issues, network problems, or the application not being properly hosted at the specified URL. As a result, the action failed, and the admin could not proceed with updating the subscription plan.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369510485//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.370Z",
    "modified": "2026-01-15T06:42:50.074Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "94924897-b662-4456-a6e2-c0284e8d050a",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC015-Payment Processing Success for Subscription",
    "description": "Verify that payment for a subscription plan is processed successfully and user subscription is activated.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Correct the URL or navigate to the correct subscription page to start the subscription purchase process.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the subscription plan or pricing section to select a subscription plan for purchase.\n        frame = context.pages[-1]\n        # Click on the 'الأسعار' (Pricing) link to view subscription plans.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'اشترك' button for the monthly subscription plan to select it for purchase.\n        frame = context.pages[-1]\n        # Click on the 'اشترك' button for the monthly subscription plan.\n        elem = frame.locator('xpath=html/body/main/section[3]/div/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form fields: full name, WhatsApp number, check WhatsApp checkbox, email, and password, then submit the form to complete the payment and activate the subscription.\n        frame = context.pages[-1]\n        # Input full name in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input WhatsApp phone number in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the 'هذا الرقم عليه واتساب' checkbox to confirm WhatsApp number.\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input email address in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the 'تسجيل وبدء الباقة' button to submit the registration form and start the subscription.\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the registration form with new unique user details and submit again to complete the payment and activate the subscription.\n        frame = context.pages[-1]\n        # Input a new unique full name in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('New User')\n        \n\n        frame = context.pages[-1]\n        # Input a new unique WhatsApp phone number in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01098765432')\n        \n\n        frame = context.pages[-1]\n        # Check the 'هذا الرقم عليه واتساب' checkbox to confirm WhatsApp number.\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input a new unique email address in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('newuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input a new password in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('NewPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the 'تسجيل وبدء الباقة' button to submit the registration form and start the subscription.\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a valid transaction reference, upload a payment receipt image, and click the confirm payment button to complete the payment and activate the subscription.\n        frame = context.pages[-1]\n        # Input last 4 digits of the transaction reference for payment confirmation.\n        elem = frame.locator('xpath=html/body/div/div[2]/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Subscription Plan Activated Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Payment for the subscription plan was not processed successfully and the user subscription was not activated as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that the payment for a subscription plan was processed successfully and that the user's subscription was activated. However, the last action performed was a navigation attempt to the URL 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, preventing the test from proceeding. \n\nThe error occurred because the specified URL may be incorrect, the server hosting the application might be down, or there could be network issues preventing access to the page. To resolve this, you should check the URL for accuracy, ensure that the server is running, and verify your network connection. Once the navigation issue is fixed, you can retry the subscription process.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459368379027//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.378Z",
    "modified": "2026-01-15T06:42:48.495Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "afd5e8fd-ed9c-4201-b1d5-faf6c6e98fcd",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC016-Payment Processing Failure with Invalid Payment Details",
    "description": "Ensure payment fails appropriately when invalid or declined payment details are used and user is notified.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Resolve the page loading issue or navigate to a valid page where subscription plans can be selected.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the subscription plan or pricing section to select a subscription plan for purchase.\n        frame = context.pages[-1]\n        # Click on the 'الأسعار' (Pricing) link to view subscription plans.\n        elem = frame.locator('xpath=html/body/header/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'اشترك' button for the monthly subscription plan to select it for purchase.\n        frame = context.pages[-1]\n        # Click on the 'اشترك' button for the monthly subscription plan.\n        elem = frame.locator('xpath=html/body/main/section[3]/div/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form with valid user details to proceed to the payment step.\n        frame = context.pages[-1]\n        # Enter full name in the registration form.\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Enter WhatsApp phone number.\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the 'هذا الرقم عليه واتساب' checkbox.\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Enter email address.\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Enter password.\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the 'تسجيل وبدء الباقة' button to submit the registration form and proceed.\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to the subscription plans or payment page to test entering invalid or declined payment details.\n        frame = context.pages[-1]\n        # Click on 'عودة للرئيسية' to go back to the main page or subscription plans.\n        elem = frame.locator('xpath=html/body/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Payment Successful! Thank you for your purchase.').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Payment was expected to be rejected with an error message due to invalid or declined payment details, but a success message was found instead.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that the payment process fails appropriately when invalid or declined payment details are used, and that the user is notified of this failure. However, the last action performed was a navigation attempt to the URL 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, preventing any further actions from being executed, including the payment process.\n\nThe error occurred because the page at 'http://localhost:3001/' either does not exist, is not reachable, or is taking too long to respond. As a result, the test could not proceed to the point where it could validate the payment failure notification. To resolve this issue, you should check the server hosting the application to ensure it is running correctly and that the URL is accessible. Once the page loads successfully, you can then proceed with testing the payment functionality.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459370410703//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.386Z",
    "modified": "2026-01-15T06:42:50.543Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "8aeca7d5-f053-4bc0-8462-504e8606f92f",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC017-Content Services Return Hadith Data Correctly",
    "description": "Verify that the content management service fetches and returns Hadith content as expected.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Correct the API request URL to properly request Hadith content from the content service API.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Request Hadith content via content service API.\n        await page.goto('http://localhost:3001/api/hadith', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Authenticate with the content service API to gain access to Hadith content.\n        await page.goto('http://localhost:3001/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input valid phone/email and password, then submit the login form to authenticate.\n        frame = context.pages[-1]\n        # Input phone/email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to find or create valid credentials to authenticate or explore alternative ways to access Hadith content.\n        frame = context.pages[-1]\n        # Click on 'إنشاء حساب جديد' to create a new account for valid credentials\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form with valid details and submit to create a new account.\n        frame = context.pages[-1]\n        # Input full name\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input WhatsApp number\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the WhatsApp number confirmation checkbox\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input email\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the register and start button to submit the form\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to the login page to attempt login with known credentials or explore password recovery options.\n        frame = context.pages[-1]\n        # Click on 'تسجيل الدخول' link to go back to the login page\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid phone/email and password, then submit the login form to authenticate.\n        frame = context.pages[-1]\n        # Input phone/email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Request Hadith content via the authenticated content service API endpoint.\n        await page.goto('http://localhost:3001/api/hadith', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Verify the correct API endpoint for fetching Hadith content or check for alternative ways to access Hadith content in the service.\n        await page.goto('http://localhost:3001/api', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate back to the dashboard or main user interface to look for any links, buttons, or menus that might provide access to Hadith content or API documentation.\n        await page.goto('http://localhost:3001/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'التذكيرات الإسلامية' link to access Islamic reminders which may include Hadith content.\n        frame = context.pages[-1]\n        # Click on 'التذكيرات الإسلامية' link to access Islamic reminders\n        elem = frame.locator('xpath=html/body/div[2]/aside/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'الأذكار والمحتوى' button to access Azkar and content which may include Hadith content.\n        frame = context.pages[-1]\n        # Click on 'الأذكار والمحتوى' button to access Azkar and content\n        elem = frame.locator('xpath=html/body/div[2]/main/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Hadith Content Successfully Loaded').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The content management service did not fetch and return Hadith content as expected. Hadith content was not found on the page after API request and authentication steps.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that the content management service fetches and returns Hadith content as expected. However, the last action performed was a navigation attempt to 'http://localhost:3001/' which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected timeframe, possibly due to the server being down, the URL being incorrect, or network issues. As a result, the action did not pass, and the expected content was not retrieved. To resolve this, check the server status, ensure the URL is correct, and verify network connectivity.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459368883885//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.396Z",
    "modified": "2026-01-15T06:42:49.675Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "aee23945-e0f6-4256-9d9c-16a5d6ffae4a",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC018-Audit Logging Records User Activities",
    "description": "Verify that user activities such as login, subscription changes, and reminder updates are recorded in audit logs.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Correct the URL or find a valid entry point to start the user login process.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the login link to start the user login process.\n        frame = context.pages[-1]\n        # Click on the 'دخول' (Login) link to start user login\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input user credentials and submit the login form.\n        frame = context.pages[-1]\n        # Input user phone/email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input user password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a new account to proceed with the task since login with existing credentials failed.\n        frame = context.pages[-1]\n        # Click on 'إنشاء حساب جديد' (Create new account) to register a new user\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the registration form with valid user details and submit to create a new account.\n        frame = context.pages[-1]\n        # Input full name for new user registration\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input WhatsApp phone number for new user registration\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('01012345678')\n        \n\n        frame = context.pages[-1]\n        # Check the WhatsApp number confirmation checkbox\n        elem = frame.locator('xpath=html/body/div/form/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input email for new user registration\n        elem = frame.locator('xpath=html/body/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for new user registration\n        elem = frame.locator('xpath=html/body/div/form/div[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the submit button to register and start the subscription\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to login page to retry login with existing credentials or try password recovery if available.\n        frame = context.pages[-1]\n        # Click on 'تسجيل الدخول' (Login) link to go back to login page\n        elem = frame.locator('xpath=html/body/div/div[3]/p/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid user credentials and submit the login form to perform login.\n        frame = context.pages[-1]\n        # Input user phone/email for login\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input user password for login\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'ترقية الباقة' (Upgrade Subscription) button to initiate subscription change.\n        frame = context.pages[-1]\n        # Click on 'ترقية الباقة' (Upgrade Subscription) button to start subscription change process\n        elem = frame.locator('xpath=html/body/div[2]/main/div/div[3]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'اشترك' (Subscribe) button for the monthly package to perform subscription change.\n        frame = context.pages[-1]\n        # Click on 'اشترك' (Subscribe) button for the monthly package to change subscription\n        elem = frame.locator('xpath=html/body/main/section[3]/div/div[2]/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate back to dashboard or subscription page to retry subscription change with existing account or find alternative method.\n        frame = context.pages[-1]\n        # Click on 'عودة للرئيسية' (Back to Home) link to return to dashboard or main page\n        elem = frame.locator('xpath=html/body/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Audit Log Entry Confirmed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: User activities such as login, subscription changes, and reminder updates were NOT recorded in the audit logs as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to verify that user activities are recorded in audit logs, specifically after performing actions like login or subscription changes. However, the last action attempted to navigate to the URL 'http://localhost:3001/' but failed due to a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, which could be due to several reasons such as the server being down, the URL being incorrect, or network issues. As a result, the action did not pass, and the expected verification of user activities could not be completed. To resolve this, please check the URL for correctness, ensure the server is running, and verify network connectivity.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369658171//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.404Z",
    "modified": "2026-01-15T06:42:49.789Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "5d4f2db6-7d82-4d62-9fd4-5a36a02b3b95",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC019-User Settings Persistence across Sessions",
    "description": "Ensure that changes to user settings including location and reminder preferences persist after logout and login.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the correct login page or home page to start the test.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the login link to proceed to the login page.\n        frame = context.pages[-1]\n        # Click on the 'دخول' (Login) link to go to the login page\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input user credentials and click login button to proceed.\n        frame = context.pages[-1]\n        # Input user identifier (email)\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input user password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid user credentials and click login button to proceed.\n        frame = context.pages[-1]\n        # Input valid user identifier (email)\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid user password\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit valid credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User settings have been reset to default').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: User settings changes including location and reminder preferences did not persist after logout and login as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that user settings persist after logout and login. However, the last action of navigating to the login page (http://localhost:3001/) failed due to a timeout error. This indicates that the page did not load within the expected time frame of 10 seconds. \n\nThe error occurred because the page may be unresponsive, the server could be down, or there might be network issues preventing the page from loading. As a result, the test could not proceed to verify if the user settings were retained, leading to a failure in achieving the task goal.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369672024//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.412Z",
    "modified": "2026-01-15T06:42:49.817Z"
  },
  {
    "projectId": "9c18406d-e3f2-4697-be00-357d2c46df3f",
    "testId": "a375015e-2ac1-48cc-af68-d5708971014e",
    "userId": "94e8a438-3021-7072-b548-aeabefb7ee44",
    "title": "TC020-Handle Invalid JWT Tokens on Secured Endpoints",
    "description": "Ensure the system properly rejects requests with invalid or expired JWT tokens and returns appropriate errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3001/http://localhost:3001/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Correct the URL or find a valid endpoint to test JWT token validation.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to login or secured area to attempt access with invalid or expired JWT tokens.\n        frame = context.pages[-1]\n        # Click on 'دخول' (Login) to access login page or secured area\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to login with invalid credentials to simulate invalid JWT token scenario.\n        frame = context.pages[-1]\n        # Input invalid user identifier to simulate invalid JWT token\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid_user@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input invalid password to simulate invalid JWT token\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid_password')\n        \n\n        frame = context.pages[-1]\n        # Click login button to attempt login with invalid credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to a secured endpoint or API to test access with invalid or expired JWT tokens.\n        await page.goto('http://localhost:3001/api/secured-endpoint', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate back to the homepage or a valid page to resume testing.\n        await page.goto('http://localhost:3001/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Navigate to login page to obtain a valid JWT token or find a secured area to test token validation.\n        frame = context.pages[-1]\n        # Click on 'دخول' (Login) to access login page\n        elem = frame.locator('xpath=html/body/header/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid credentials and submit login form to obtain a valid JWT token.\n        frame = context.pages[-1]\n        # Input valid user identifier to obtain valid JWT token\n        elem = frame.locator('xpath=html/body/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('valid_user@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password to obtain valid JWT token\n        elem = frame.locator('xpath=html/body/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('valid_password')\n        \n\n        frame = context.pages[-1]\n        # Click login button to submit valid credentials\n        elem = frame.locator('xpath=html/body/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The system did not properly reject requests with invalid or expired JWT tokens. Expected an authentication error, but access was granted.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task goal was to ensure that the system properly rejects requests with invalid or expired JWT tokens and returns appropriate errors. However, the last action performed was a navigation attempt to the URL 'http://localhost:3001/', which resulted in a timeout error after 10 seconds. This indicates that the page did not load within the expected time frame, possibly due to the server being down, the URL being incorrect, or the application not running on the specified port.\n\nSince the navigation to the page failed, the subsequent validation of JWT token handling could not be executed. To resolve this issue, you should:\n1. Verify that the server is running and accessible at 'http://localhost:3001/'.\n2. Check if the URL is correct and that the application is configured to listen on the specified port.\n3. If the server is running, consider increasing the timeout duration to allow for slower responses.\n\nOnce the navigation issue is resolved, you can proceed with testing the JWT token validation as intended.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/94e8a438-3021-7072-b548-aeabefb7ee44/1768459369928259//tmp/test_task/result.webm",
    "created": "2026-01-15T05:28:05.441Z",
    "modified": "2026-01-15T06:42:50.066Z"
  }
]
